## m-way 查找树

**AIM: 降低内存查找开销，增加运算次数**

### 定义

- 根节点最多m个子树，结构 $n, A_0, (E_1, A_1), (E_2, A_2), ..., (E_n, A_n)$
- $A_i$ 是指向子树的指针，$E_i$ 是元素，每个元素都有一个关键字 $$ $K$
- 每个节点最多 $m-1$ 个元素，子树对应切分

```
            [10, 20]
           /   |   \\\\
       [5]   [15]  [25, 30]
```

### 查找

- m较小，线性查找
- m较大，二分查找

## B-树

- 根节点至少两个孩子
- 所有中间节点至少 $ceil(\frac{m}{2})$ 个孩子
- 所有外部节点同层

*3阶B树也叫2-3树，4阶B树也叫2-3-4树*

### 元素个数

$N \ge 2 * ceil((\frac{m}{2}) ^ {l-1}) - 1$

### 插入

插入传递到外部节点，假设达到m个节点

- 二分分裂（舍去一个值），向父级传递新的指针元组（舍去的值）
- 递归传递
- 对于根节点的分裂，生成一个单元素节点链接

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/28def99e-2c49-46d0-ba94-121738cb4578/b81492f2-085e-4002-bcca-0a2b374d08f5/image.png)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/28def99e-2c49-46d0-ba94-121738cb4578/66713d4f-f52b-4217-8c00-df4bc526ada3/image.png)

### 删除

- 如果删除中间节点，用前子树的最大或后子树的最小替换
- 如果删除叶子节点p，
  - p是根节点，直接删除，写回/为空
  - 删除后p还剩 $ceil(\frac{m}{2}) - 1$ 个元素，写回
  - 还剩 $ceil(\frac{m}{2}) - 2$ 个元素，兄弟还有 $ceil(\frac{m}{2})$ 个，小的从父亲拿一个，大的往父亲赛一个
  - 还剩 $ceil(\frac{m}{2}) - 2$ 个元素，兄弟还有 $ceil(\frac{m}{2}) - 1$ 个，合并，递归向上传递

## B+树

两类节点 索引和数据

### 定义

- 数据同层都叶子，双向链表全链接
- 索引部分是m阶B-树，只有关键字，不包含元素
- 索引结构 $n, A_0, (K_1, A_1), (K_2, A_2), ..., (K_n, A_n)$ 其中 $K_i$ 是关键字，子树关键字小于后值，大于等于前值

### 查找

可以进行精确匹配和范围查找

### 插入

数据节点过满，较大的一半移到新节点中，向父亲插入新节点中的最小值，递归

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/28def99e-2c49-46d0-ba94-121738cb4578/4f158fac-f85b-4282-897c-05026e86905b/image.png)

## 删除

元素数目小于 $ceil(\frac{c}{2})$ 就视为不完善

均分合并算法参上